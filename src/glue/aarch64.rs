// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
struct Init_Windowed {
    pub f2: roc_std::RocStr,
    pub f0: u32,
    pub f1: u32,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Init {
    Fullscreen = 0,
    Windowed = 1,
}

impl core::fmt::Debug for discriminant_Init {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Fullscreen => f.write_str("discriminant_Init::Fullscreen"),
            Self::Windowed => f.write_str("discriminant_Init::Windowed"),
        }
    }
}

#[repr(C, align(8))]
pub union union_Init {
    Fullscreen: (),
    Windowed: core::mem::ManuallyDrop<Init_Windowed>,
}

const _SIZE_CHECK_union_Init: () = assert!(core::mem::size_of::<union_Init>() == 40);
const _ALIGN_CHECK_union_Init: () = assert!(core::mem::align_of::<union_Init>() == 8);

const _SIZE_CHECK_Init: () = assert!(core::mem::size_of::<Init>() == 40);
const _ALIGN_CHECK_Init: () = assert!(core::mem::align_of::<Init>() == 8);

impl Init {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Init {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Init>(*bytes.as_ptr().add(32))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Init) {
        let discriminant_ptr: *mut discriminant_Init = (self as *mut Init).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Init {
    payload: union_Init,
    discriminant: discriminant_Init,
}

impl Clone for Init {
    fn clone(&self) -> Self {
        use discriminant_Init::*;

        let payload = unsafe {
            match self.discriminant {
                Fullscreen => union_Init {
                    Fullscreen: self.payload.Fullscreen.clone(),
                },
                Windowed => union_Init {
                    Windowed: self.payload.Windowed.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Init {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Init::*;

        unsafe {
            match self.discriminant {
                Fullscreen => {
                    let field: &() = &self.payload.Fullscreen;
                    f.debug_tuple("Init::Fullscreen").field(field).finish()
                },
                Windowed => {
                    let field: &Init_Windowed = &self.payload.Windowed;
                    f.debug_tuple("Init::Windowed").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Init {}

impl PartialEq for Init {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Init::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Fullscreen => self.payload.Fullscreen == other.payload.Fullscreen,
                Windowed => self.payload.Windowed == other.payload.Windowed,
            }
        }
    }
}

impl Ord for Init {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Init {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Init::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Fullscreen => self.payload.Fullscreen.partial_cmp(&other.payload.Fullscreen),
                    Windowed => self.payload.Windowed.partial_cmp(&other.payload.Windowed),
                }
            },
        }
    }
}

impl core::hash::Hash for Init {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Init::*;

        unsafe {
            match self.discriminant {
                Fullscreen => self.payload.Fullscreen.hash(state),
                Windowed => self.payload.Windowed.hash(state),
            }
        }
    }
}

impl Init {

    pub fn is_Fullscreen(&self) -> bool {
        matches!(self.discriminant, discriminant_Init::Fullscreen)
    }

    pub fn unwrap_Windowed(mut self) -> Init_Windowed {
        debug_assert_eq!(self.discriminant, discriminant_Init::Windowed);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Windowed) }
    }

    pub fn is_Windowed(&self) -> bool {
        matches!(self.discriminant, discriminant_Init::Windowed)
    }
}



impl Init {

    pub fn Fullscreen() -> Self {
        Self {
            discriminant: discriminant_Init::Fullscreen,
            payload: union_Init {
                Fullscreen: (),
            }
        }
    }

    pub fn Windowed(payload: Init_Windowed) -> Self {
        Self {
            discriminant: discriminant_Init::Windowed,
            payload: union_Init {
                Windowed: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for Init {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Init::Fullscreen => {}
            discriminant_Init::Windowed => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Windowed) },
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R1 {
    pub init: Init,
    pub draw: (),
}



pub fn mainForHost() -> R1 {
    extern "C" {
        fn roc__mainForHost_1_exposed_generic(_: *mut R1);
    }

    let mut ret = std::mem::MaybeUninit::uninit();

    unsafe { roc__mainForHost_1_exposed_generic(ret.as_mut_ptr(), ) };

    unsafe { ret.assume_init() }
}